from Crypto.Util.number import *

c1 = 36918910341116680090654563538246204134840776220077189276689868322808977412566781872132517635399441578464309667998925236488280867210758507758915311644529399878185776345227817559234605958783077866016808605942558810445187434690812992072238407431218047312484354859724174751718700409405142819140636116559320641695
c2 = 15601788304485903964195122196382181273808496834343051747331984997977255326224514191280515875796224074672957848566506948553165091090701291545031857563686815297483181025074113978465751897596411324331847008870832527695258040104858667684793196948970048750296571273364559767074262996595282324974180754813257013752
p = 12101696894052331138951718202838643670037274599483776996203693662637821825873973767235442427190607145999472731101517998719984942030184683388441121181962123
r = 10199001137987151966640837133782537428248507382360655526592866939552984259171772190788036403425837649697437126360866173688083643144865107648483668545682383
public_exponent = 31413537523

# Calculate modular inverses
q1 = p
q2 = r

# Calculate CRT coefficients
dp = inverse(public_exponent, p-1)
dq = inverse(public_exponent, q1-1)
dr = inverse(public_exponent, q2-1)

# Compute individual parts using CRT
m1 = pow(c1, dp, p)
m2 = pow(c2, dq, q1)
m3 = pow(c2, dr, q2)

# Handle the case where q1 is equal to p
if q1 == p:
    h1 = 1
    h2 = 0
else:
    h1 = q1 * inverse(q1, p)
    h2 = p * inverse(p, q1)

h3 = q2 * inverse(q2, p)

result = (m1 * h1 + m2 * h2 + m3 * h3) % (p * q1 * q2)

# Convert the result back to bytes and decode
decrypted_message = long_to_bytes(result).decode('utf-8')

print("Decrypted message:", decrypted_message)
